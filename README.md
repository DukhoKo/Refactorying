# 중복코드
## 함수 추출하기 (Extract Function)   중요!!﻿

의도와 구현에 대해서만 분리할것 

코드를 읽을때 이 메소드가 어떤 일을 하는지 파악을 할때 코드를 마치 책 처럼 이해가 되지않는다면 구현을 보고있다고 생각하면 된다. 잘 읽힌다면 의도이다.

한줄짜리 메소드도 의도가 잘 드러난다면 좋다.



이클립스에서 사용하는 방법 1.

=> 추출하고 싶은 부분을 마우스로 드래그 해서, 오른쪽 버튼을 누르면 메뉴가 나오는데, 리펙토링->메소드 추출을 선택하면 된다.

이클립스에서 사용하는 방법 2.

 => 추출하고 싶은 부분을 마우스로 드래그 해서, 'ALT+SHIFT+M'



## 코드 정리

변수 선언은 메소드 안에서 최상단에 하지말고 해당 변수가 쓰기 직전에 선언해주자.

단축키 : eclipse의 경우 이동시키고 싶은 줄 맨앞에 커서 놓고 alt + 화살표 (이렇게 하면 복사하고 지워서 붙여넣을 필요없음)


## 메소드 올리기

하위 클래스에 있는 코드가 상위 클래스가 아닌 하위 클래스 기능에 의존하고 있다면 "필드 올리기"를 적용한 이후에 적용

eclipse 에서 pull up 기능 


# 긴 함수
## 임시 변수를 질의 변수로 바꾸기
 Replace Temp with Query ( 여기서의 Query는 함수를 의미한다.)

 임시 변수를 만들어 내는 표현식을 함수로 빼내라!

## 매개변수 객체 만들기

X( A, B ) 

Y(A, B, C) 처럼 A와 B가 여러 메소드에 걸쳐 나타난다면 A와 B를 묶은 자료구조를 만든다.

객체로 바꿀 A,B를 선택하고 Alt + Shift + T를 클릭하면 리팩토링 메뉴가 뜨는데 

Eclipse 3.3에 추가된 기능인 Introduce Parameter Object를 선택하면된다. 그리고 inner 클래스로 만들지 일반 클래스로 만들지 선택하고 ok 누르면 된다.


## 객체 통째로 넘기기 (Preserve Whole Object)

어떤 한 레코드에서 구할 수 있는 여러 값들을 함수에 전달하는 경우, 해당 매개변수를 레코드 하나로 교체할 수 있다.

매개변수 목록을 줄일 수 있다. 해당 메소드의 위치가 적절한지 생각해야한다. 

## 함수를 명령으로 바꾸기

Command 패턴(디자인패턴)을 적용하면 다음과 같은 장점을 가질수 있다.

1) undo 기능을 만들 수 있다.

2) 더 복잡한 기능을 구현하는데 필요한 여러 메소드를 추가할수 있다. 

3) 상속이나 템플릿을 활용 할 수 있다.

4) 복잡한 메소드를 여러 메소드나 필드를 활용해서 쪼갤 수도 있다.

코드는 간추릴수 있지만 복잡도는 커질수 있다.


## 조건문 분해하기 (Decompose Conditional)

기술적으로 "함수 추출하기"와 동일한 리팩토링이지만 의도만 다를뿐이다.

```c
private Participant findParticipant(String username, List<participant> participants) {

    if ( participants.stream().noneMatch(p -> p.userName().equals(username) ) { 

        participants = new participants(username);

        participants.add(participant);

    } else {

        participant = participants.stream().filter(p -> p.username().equals(username)).findFirst().orElseThrow();

    }

    return participant;

}
```
이 문장이 함수 추출하기처럼 리팩토링을 하면
```c
private Participant findParticipant(String username, List<participant> participants) {

    if( isNewParticipants(username, participants)){

        participant = createNewParticipant( username, participants);

    } else {

        participant = findExistingParticipant(username, participants);

    }

    return participant;

}

private boolean isNewParticipants(String username, List<participant> participants)_ {

    return participants.stream().noneMatch(p -> p.userName().equals(username);

}

private Participaant createNewParticipant(String username, List<participant> participants)_ {

    Participant participant;

    participant = new Participant(username);

    participants.add(participant);

    return participant;

}

private Participaant  findExistingParticipant(String username, List<participant> participants)_ {

    Participant participant;

    participant = participants.stream().filter(p -> p.username().equals(username)).findFirst().orElseThrow();

    return participant;

}
```
이렇게 리팩토링 할수 있고 또 리팩토링을 한다면
```c
private Participant findParticipant(String username, List<participant> participants) {

    return isNewParticipant(username, participants) ? createNewParticipant( username, participants) : findExistingParticipant(username, participants);

}
```
삼항 연산자를 써서 이렇게까지 리팩토링을 할수 있다.


## 반복문 쪼개기 ( Split Loop )

하나의 반복문에서 여러 다른 작업을 하는 코드를 쉽게 찾아볼수 있다.
해당 반복문을 수정 할 때 여러 작업을 모두 고려하며 코딩을 해야한다.
성능 문제를 야기 할 수 있지만 '리팩토링'은 '성능 최적화'와 별개의 작업이다. 리팩토링을 하고 성능최적화를 하길...

```c
for ( ~ ) {

    기능 1 

    if(){ //기능 2

    }

}
```
라면 

for문을 2개 만들고 하나의 for문에는 기능1만 또 다른 하나의 for문에는 기능2를 넣어서 별도의 메소드로 빼고 해당 메소드 들을 호출한다.
```c
{

AAA();

BBB();

}

private AAA () {

    for(){

        기능1;

    }

}

private BBB() {}

    for(){

        if() {기능2; }

    }

}
```

## 조건문을 다형성으로 바꾸기 ( Replace Conditional with Polymorphism)

여러 타입에 따라 각기 다른 로직으로 처리해야 하는 경우에 다형성을 적용해서 조건문을 보다 명확하게 분리할 수 있다. 반복되는 switch문을 각기 다른 클래스를 만들어 제거 할 수 있다.
공통으로 사용되는 로직은 상위클래스에 두고 달라지는 부분만 하위클래스에 둠으로써, 달라지는 부분만 강조할 수 있다.
모든 조건문을 다형성으로 바꿔야 하는 것은 아니다.

# 긴 매개변수 목록
## 긴 매개변수 목록 (Long Parameter List)

매개변수들이 너무 많으면

어떤 매개 변수를 다른 매개변수를 통해 알아낼수 있다면 : "매개변수를 질의함수로 바꾸기" ,

세부적인 데이터를 가져와서 여러 매개변수로 넘기는대신 : "객체 통째로 넘기기",

일부 매개변수들이 대부분 같이 넘겨진다면 : "매개변수 객체 만들기"

매개변수가 플래그로 사용된다면 : "플래그 인수 제거하기"


## 매개변수를 질의 함수로 바꾸기 (Replace Parameter with Query)

함수의 매개변수 목록은 함수의 다양성을 대변하며, 짧을수록 이해하기 좋다.
어떤 한 매개변수를 다른 매개변수를 통해 알아낼수있다 => "중복 매개변수"라고 생각
매개변수에 값을 전달하는 것은 " 함수를 호출하는 쪽"의 책임이다. 가능하면 함수를 호출하는 쪽의 책임을 줄이고 함수 내부에서 책임지도록 노력한다.
"임시 변수를 질의 함수로 바꾸기"와 "함수 선언 변경하기"를 통해 이 리팩토링을 적용


## 플래그 인수 제거하기 (Remove Flag Argument)

한 메소드에 flag가 2개 이상이면 해당 메소드는 너무 많은 일을 하는것이다. 분리해주어야한다.

1개라면 메소드를 호출하는 쪽에서는 호출할 메소드에 들어가서 보기전까지 flag에 대해서 알수있는 정보가 없다.

조건문 분해하기(Decompose Condition) 리팩토링 기술을 활용 할수 있다.


## 여러 함수를 클래스로 묶기 (Combine Functions into Class)

별도의 클래스를 따로 만들어서 관련있는 데이터를 한곳에 모으고(메소드를 모아놓으면 매개변수도 많이 줄일수있다.)

생성자로 해당 클래스 호출시 넘겨주는 파라미터를 받아서 클래스안에서 메소드를 만들어서 묶어준다.

move to class 기능 사용

# 전역 데이터
## 전역 데이터 (Global Data)

ex) 자바의 public static 변수

아무곳에서나 변경될 수 있다는 문제가 있따.
어떤 코드로 인해 값이 바뀐것인지 파악하기 어렵다.
'변수 캡슐화(Encapsulate Variable)'를 적용해서 접근을 제어하거나 어디서 사용하는지 파악하기 쉽게 만들 수 있다.
적용하면 변수 변경이 쉬워지고 변수에 접근 제약을 할수 있다.

## 변수 캡슐화하기 (Encapsulate Variable)

메소드는 점진적으로 새로운 메소드로 변경할 수 있으나, 데이터는 한번에 모두 변경해야 한다.
데이터 구조를 변경하는 작업은 그보다는 조금 더 수월한 메소드 구조 변경 작업으로 대체할 수 있다.
데이터가 사용되는 범위가 클수록 캡슐화를 하는것이 더 중요해진다.
   - 함수를 사용해서 값을 변경하면 보다 쉽게 검증 로직을 추가하거나 변경에 따르는 후속 작업을       추가하는 것이 편리하다.

불변 데이터의 경우에는 이런 리팩토링을 적용할 필요가 없다.


ex_)

todo.status = 4;
todo.isRepeat = false;

이렇게 변수를 사용중이라면 
todo class에서 

private int status;
private boolean isRepeat; 로 선언되어있는것을 getter / setter를 이용해서 메소드화 해서 
todo.setStatus();
todo.setIsRepeat();

로 처리함으로써 변수를 캡슐화 시킨다.

# 가변데이터
## 가변 데이터 (Mutable Data)

데이터를 변경하다보면 예상치 못했던 결과나 해결하기 어려운 버그가 발생하기도 한다.
side effect : 어떠한 변경사항이 다른곳에 영향을 주는 것

함수형 프로그래밍 언어는 데이터를 변경하지 않고 복사본을 전달한다. 하지만 그밖의 프로그래밍 언어는 데이터 변경을 허용하고 있다. 따라서 변경되는 데이터 사용 시 발생할 수 있는 리스크를 관리할 수 있는 방법을 적용하는 것이 좋다.

* 관련 리팩토링
 1. "변수 캡슐화하기 (Encapsulate Variable)"를 적용해 데이터를 변경할 수 있는 메소드를 제한하고 관리할 수 있다. 
 2. "변수 쪼개기 (Split Variable)"을 사용해 여러 데이터를 저장하는 변수를 나눌 수 있다.
 3. "코드 정리하기 (Slide Statements)"를 사용해 데이터를 변경하는 코드를 분리하고 피할 수 있다. (질의 함수와 변경 함수를 분리하기 위한 리팩토링 기술)
 4. "함수 추출하기 (Extract Function)"으로 데이터를 변경하는 코드로부터 사이드 이팩트가 없는 코드(조회하는 코드)를 분리할 수 있다. (질의 함수와 변경 함수를 분리하기 위한 리팩토링 기술)
 5. "질의 함수와 변경 함수 분리하기 (Separate Query from Modifier)"를 적용해서 클라이언트가 원하는 경우에만 사이드 이팩트가 있는 함수를 호출하도록 API를 개선할 수 있다.
 6. 가능하다면 "세터 제거하기 (Remove Setting Method)"를 적용한다. (데이터가 변경될수있는 여지를 줄여주는것)
 7. 계산해서 알아낼 수 있는 값에는 "파생 변수를 질의 함수로 바꾸기 (Replace Derived Variable with Query)"를 적용할 수 있다.
 8. 변수가 사용되는 범위를 제한하려면 "여러 함수를 클래스로 묶기 (Combine Functions into Class)" 또는 "여러 함수를 변환 함수로 묶기(Combine Functions into Transform)"을 적용할 수 있다.
 9. "참조를 값으로 바꾸기 (Change Reference to Value)"를 적용해서 데이터 일부를 변경하기 보다는 데이터 전체를 교체할 수 있다.

## 변수 쪼개기 (Split Variable)

* 어떤 변수가 여러번 재할당 되어도 적절한 경우
  - 반복문에서 순회하는데 사용하는 변수 또는 인덱스
  - 값을 축적시키는데 사용하는 변수

그밖에 경우에 재할당 되는 변수가 있다면 해당 변수는 여러 용도로 사용되는 것이며 변수를 분리해야 더 이해하기 좋은 코드를 만들 수 있다.
  - 변수 하나 당 하나의 책임을 지도록 만든다.
  - 상수를 활용하자. (자바스크립트의 const, 자바의 final)



## 질의 함수와 변경 함수 분리하기 (Separate Query from Modifier)

* "눈에 띌만한" 사이드 이팩트 없이 값을 조회할 수 있는 메소드는 테스트 하기도 쉽고, 메소드를 이동하기도 현하다.
* 명령-조회 분리 (command-query separation) 규칙 :
    - 어떤 값을 리턴하는 함수는 사이드 이팩트가 없어야 한다.
* "눈에 띌만한" 사이드 이팩트
    - 가령, 캐시는 중요한 객체 상태 변화는 아니다. 따라서 어떤 메소드 호출로 인해, 캐시 데이터를 변경하더라도 분리할 필요는 없다.

## 세터 제거하기 (Remove Setting Method)

세터를 제공한다는 것은 해당 필드가 변경될 수 있다는 것을 뜻한다.
객체 생성시 처음 설정된 값이 변경될 필요가 없다면 해당 값을 설정할 수 있는 생성자를 만들고 세터를 제거해서 변경될 수 있는 가능성을 제거 해야 한다.

## 파생 변수를 질의 함수로 바꾸기 (Replace Derived Variable with Query)

* 변경할 수 있는 데이터를 최대한 줄이도록 노력해야 한다.
* 계산해서 알아낼 수 있는 변수는 제거할 수 있다.
   - 계산 자체가 데이터의 의미를 잘 표현하는 경우도 있다.
   - 해당 변수가 어디선가 잘못된 값으로 수정될 수 있는 가능성을 제거할 수 있다.
* 계산에 필요한 데이터가 변하지 않는 값이라면, 계산의 결과에 해당하는 데이터 역시 불변 데이터기 때문에 해당 변수는 그대로 유지할 수 있다.

## 여러 함수를 변환 함수로 묶기 (Combine Functions into Transform)

* 관련있는 여러 파생 변수를 만들어내는 함수가 여러곳에서 만들어지고 사용된다면 그러한 파생 변수를 "변환 함수 (transform function)"를 통해 한곳으로 모아둘수 있다.
* 소스 데이터가 변경될수 있는 경우에는 "여러 함수를 클래스로 묶기 (Combine Functions into class)"를 사용하는 것이 적절하다.
* 소스 데이터가 변경되지 않는 경우에는 두 가지 방법(클래스로 묶기 / 트랜스폼으로 묶기)을 모두 사용할 수 있지만, 변환 함수를 사용해서 불변 데이터의 필드로 생성해두고 재사용할 수도 있다.

## 참조를 값으로 바꾸기 (Change Reference to Value)

* 레퍼런스 (Reference) 객체 vs 값 (Value) 객체
- "Objects that are equal due to the value of their properties, in this case their x and y coordinates, are called value objects"
- 값 객체는 객체가 가진 필드의 값으로 동일성을 확인한다.
- 값 객체는 변하지 않는다.
- 어떤 객체의 변경 내역을 다른 곳으로 전파시키고 싶다면 레퍼런수, 아니면 값 객체를 사용한다.

# 뒤엉킨 변경
## 뒤엉킨 변경 (Divergent Change)
좋은 코드라 하면 응집도(얼마나 관련있는 데이터나 function들이 한곳에 밀집되어있는가)는 높아야하고 결합도(관련없는것들이 타이트하지않게 되어있어야)는 낮아야한다.
그렇지 않으면 어떤 변경 사항을 만들만 매번 동일한 클래스를 고치게 된다. 

* 소프트웨어는 변경에 유연하게(soft) 대처할 수 있어야 한다.
* 어떤 한 모듈이 (함수 또는 클래스가) 여러가지 이유로 다양하게 변경되어야하는 상황
- 예) 새로운 결제 방식을 도입하거나, DB를 변경할 때 동일한 클래스에 여러 메소드를 수정해야 하는 경우
* 서로 다른 문제는 서로 다른 모듈에서 해결해야 한다.
- 모듈의 책임이 분리되어 있을수록 해당 문맥을 더 잘 이해할 수 있으며 다른 문제는 신경쓰지 않아도 된다.
* 관련 리팩토링 기술
   1. "단계 쪼개기 (Split Phase)"를 사용해 서로 다른 문맥의 코드를 분리할 수 있다.
   2. "함수 옮기기 (Move Function)"를 사용해 적절한 모듈로 함수를 옮길 수 있다.
   3. 여러가지 일이 하나의 함수에 모여 있다면 "함수 추출하기 (Extract Function)"를 사용할 수 있다.
   4. 모율이 클래스 단위라면 "클래스 추출하기 (Extract Class)"를 사용해 별도의 클래스로 분리할 수 있다.

## 단계 쪼개기 (Split Phase)

* 서로 다른 일을 하는 코드를 각기 다른 모듈로 분리한다.
 - 그래야 어떤 것을 변경해야 할때, 그것과 관련있는 것만 신경쓸 수 있다.
* 여러 일을 하는 함수의 처리 과정을 각기 다른 단계로 구분할 수 있다.
 - 예) 전처리 -> 주요 작업 -> 후처리
 - 예) 컴파일러: 텍스트 읽어오기 -> 실행 가능한 형태로 변경
* 서로 다른 데이터를 사용한다면 단계를 나누는데 있어 중요한 단서가 될 수 있다.
* 중간 데이터(intermediate Data)를 만들어 단계를 구분하고 매개변수를 줄이는데 활용할 수있다.

## 함수 옮기기 (Move Function)

* 모듈화가 잘 된 소프트웨어는 최소한의 지식만으로 프로그램을 변경할 수 있다.
* 관련있는 함수나 필드가 모여있어야 더 쉽게 찾고 이해할 수 있다.
* 하지만 관련있는 함수나 필드가 항상 고정적인 것은 아니기 때문에 때에 따라 옮겨야 할 필요가 있다.
* 함수를 옮겨야 하는 경우
 - 해당 함수가 다른 문맥 (클래스)에 있는 데이터(필드)를 더 많이 참조하는 경우
 - 해당 함수를 다른 클라이언트 (클래스)에서는 필요로 하는 경우
* 함수를 옮겨갈 새로운 문맥 (클래스)이 필요한 경우에는 "여러 함수를 클래스로 묶기 (Combine Functions info Class) 또는 "클래스 추출하기 (Extract Class)"를 사용한다.
* 함수를 옮길 적당한 위치를 찾기가 어렵다면, 그대로 두어도 괜찮다. 언제든지 나중에 옮길 수 있다.

## 클래스 추출하기 (Extract Class)

* 클래스가 다루는 책임이 많아질수록 클래스가 점차 커진다.
* 클래스를 쪼개는 기준
 - 데이터나 메소드 중 일부가 매우 밀접한 관련이 있는 경우
 - 일부 데이터가 대부분 같이 바뀌는 경우
 - 데이터 또는 메소드 중 일부를 삭제한다면 어떻게 될 것인가?
* 하위 클래스를 만들어 책임을 분산 시킬 수도 있다.

# 산탄총 수술
## 산탄총 수술 (Shotgun Surgery)

* 어떤 한 변경 사항이 생겼을 때 여러 모듈을 (여러 함수 또는 여러 클래스를) 수정해야 하는 상황.
 - "뒤엉킨 변경" 냄새와 유사하지만 반대의 상황이다.
 - 예) 새로운 결제 방식을 도입하려면 여러 클래스의 코드를 수정해야 한다.
* 변경 사항이 여러곳에 흩어진다면 찾아서 고치기도 어렵고 중요한 변경 사항을 놓칠 수 있는 가능성도 생긴다.
* 관련 리팩토링 기술
  - "함수 옮기기(Move Function)" 또는 "필드 옮기기(Move Field)"를 사용해서 필요한 변경 내역을 하나의 클래스로 모을 수 있다.
  - 비슷한 데이터를 사용하는 여러 함수가 있다면 "여러 함수를 클래스로 묶기"를 사용할 수 있다.
  - "단계 쪼개기"를 사용해 공통으로 사용되는 함수의 결과물들을 하나로 묶을 수 있다
  - "함수 인라인(Inline Function)"과 "클래스 인라인(Inline Class)"로 흩어진 로직을 한 곳으로 모을 수 있다.

## 필드 옮기기 (Move Field)

* 좋은 데이터 구조를 가지고 있다면, 해당 데이터에 기반한 어떤 행위를 코드로 (메소드나 함수) 옮기는 것도 간편하고 단순해진다.
* 처음에는 타당해 보였떤 설계적인 의사 결정도 프로그램이 다루고 있는 도메인과 데이터 구조에 대해 더 많이 익혀나가면서, 틀린 의사 결정으로 바뀌는 경우도 있다.
* 필드를 옮기는 단서 :
  - 어떤 데이터를 항상 어떤 레코드와 함께 전달하는 경우
  - 어떤 레코드를 변경할 때 다른 레코드에 있는 필드를 변경해야 하는 경우
  - 여러 레코드에 동일한 필드를 수정해야 하는 경우
  - (여기서 언급한 '레코드'는 클래스 또는 객체로 대체할 수도 있음)
* 레코드 = 클래스 = 객체 라고 생각하면 된다.

## 함수 인라인 (Inline Function)

* "함수 추출하기 (Extract function)"의 반대에 해당하는 리팩토링
 - 함수로 추출하여 함수 이름으로 의도를 표현하는 방법
* 간혹, 함수 본문이 함수 이름 만큼 또는 그보다 더 잘 의도를 표현하는 경우도 있다.
* 함수 리팩토링이 잘못된 경우에 여러 함수를 인라인하여 커다란 함수를 만든 다음에 다시 함수 추출하기를 시도할 수 있다.
* 단순히 메소드 호출을 감싸는 우회형 (indirection) 메소드 라면 인라인을 없앨 수 있다.
* 상속 구조에서 오버라이딩 하고 있는 메소드는 인라인 할 수 없다. (다형성을 깨는 행위)(해당 메소드의 일종의 규약이니까)

## 클래스 인라인 (Inline Class)

* "클래스 추출하기 (Extract Class)"의 반대에 해당하는 리팩토링
* 리팩토링을 하는 중에 클래스의 책임을 옮기다보면 클래스의 존재 이유가 빈약해지는 경우가 발생 할 수 있다.
* 두개의 클래스를 여러 클래스로 나누는 리팩토링을 하는 경우에, 우선 "클래스 인라인"을 적용해서 두 클래스의 코드를 한 곳으로 모으고 그런 다음에 "클래스 추출하기"를 적용해서 새롭게 분리하는 리팩토링을 적용할 수 있다.

# 기능 편애
## 기능 편애 (Feature Envy)

* 어떤 모듈에 있는 함수가 다른 모듈에 있는 데이터나 함수를 더 많이 참조하는 경우에 발생한다.
 - 예) 다른 객체의 getter를 여러개 사용하는 메소드
* 관련 리팩토링 기술
 - "함수 옮기기"를 사용해서 함수를 적절한 위치로 옮긴다.
 - 함수 일부분만 다른 곳의 데이터와 함수를 많이 참조한다면 "함수 추출하기"로 함수를 나눈 다음에 함수를 옮길 수 있다.
* 만약에 여러 모듈을 참조하고 있다면? 그 중에서 가장 많은 데이터를 참조하는 곳으로 옮기거나, 함수를 여러개로 쪼개서 각 모듈로 분산 시킬 수도 있다.
* 데이터와 해당 데이터를 참조하는 행동을 같은 곳에 두도록 하자
* 예외적으로, 데이터와 행동을 분리한 디자인 패턴 (전략 패턴 또는 방문자 패턴)을 적용할 수도 있다.

# 데이터 뭉치
## 데이터 뭉치 (Data Clumps)

* 항상 뭉쳐 다니는 데이터는 한 곳으로 모아두는 것이 좋다.
 - 여러 클래스에 존재하는 비슷한 필드 목록
 - 여러 함수에 전달하는 매개변수 목록
* 관련 리팩토링 기술
 - "클래스 추출하기 (Extract Class)"를 사용해 여러 필드를 하나의 객체나 클래스로 모을 수 있다.
 - "매개변수 객체 만들기 (Introduce Parameter Object)" 또는 "객체 통째로 넘기기 (Preserve Whole Object)"를 사용해 메소드 매개변수를 개선할 수 있다.

# 기본형 집착
## 기본형 집착 (Primitive Obsession)

* 애플리케이션이 다루고 있는 도메인에 필요한 기본 타입을 만들지 않고 프로그래밍 언어가 제공하는 기본 타입을 사용하는 경우가 많다.
 - 예) 전화번호, 좌표, 돈, 범위, 온도, 수량 등
* 기본형으로는 단위 (인치 vs 미터) 또는 표기법을 표현하기 어렵다.
* 관련 리팩토링 기술
 - "기본형을 객체로 바꾸기 (Replace Primitive with Object)"
 - "타입 코드를 서브클래스로 바꾸기 (Replace Type Code with Subclasses)"
 - "조건부 로직을 다형성으로 바꾸기(Replace Conditional with Polymorphism)"
 - "클래스 추출하기 (Extract Class)"
 - "매개변수 객체 만들기 (Introduce Parameter Object)"

## 기본형을 객체로 바꾸기 (Replace Primitive with Object)

* 개발 초기에는 기본형 (숫자 또는 문자열)으로 표현한 데이터가 나중에는 해당 데이터와 관련있는 다양한 기능을 필요로 하는 경우가 발생한다.
 - 예) 문자열로 표현하던 전화번호의 지역 코드가 필요하거나 다양한 포맷을 지원하는 경우
 - 예) 숫자로 표현하던 온도의 단위 (화씨, 섭씨)를 변환하는 경우
* 기본형을 사용한 데이터를 감싸 줄 클래스를 만들면, 필요한 기능을 추가할 수 있다.

## 타입 코드를 서브클래스로 바꾸기 (Replace Type Code with Subclasses)

* 비슷하지만 다른 것들을 표현해야 하는 경우, 문자열(String), 열거형 (enum), 숫자(int) 등으로 표현하기도 한다.
 - 예) 주문 타입 , "일반 주문", "빠른 주문"
 - 예) 직원 타입, "엔지니어", "매니저", "세일즈"
* 타입을 서브클래스로 바꾸는 계기
 - 조건문을 다형성으로 표현할 수 있을때, 서브클래스를 만들고 "조건부 로직을 다형성으로 바꾸기"를 적용한다.
 - 특정 타입에만 유효한 필드가 있을 때, 서브클래스를 만들고 "필드 내리기"를 활용한다.

## 조건부 로직을 다형성으로 바꾸기 (Replace Conditional with Polymorphism)

* 복잡한 조건식을 상속과 다형성을 사용해 코드를 보다 명확하게 분리할 수 있다.
* switch문을 사용해서 타입에 따라 각기 다른 로직을 사용하는 코드
* 기본 동작과 (타입에 따른) 특수한 기능이 섞여있는 경우에 상속 구조를 만들어서 기본 동작을 상위클래스에 두고 특수한 기능을 하위클래스로 옮겨서 각 타입에 따른 "차이점"을 강조할 수 있다.
* 모든 조건문을 다형성으로 옮겨야 하는가? 단순한 조건문은 그대로 두어도 좋다. 오직 복잡한 조건문을 다형성을 활용해 좀 더 나은 코드로 만들 수 있는 경우에만 적용한다. (과용을 조심하자)

# 반복되는 switch문
## 반복되는 switch문 (Repeated Switches)

* 예전에는 switch문이 한번만 등장해도 코드 냄새로 생각하고 다형성 적용을 권장했다.
* 하지만 최근에는 다형성이 꽤 널리 사용되고 있으며, 여러 프로그래밍 언어에서 보다 세련된 형태의 swtich문을 지원하고 있다.
* 따라서 오늘날은 "반복해서 등장하는 동일한 switch문"을 냄새로 여기고 있따
* 반복해서 동일한 switch문이 존재할 경우, 새로운 조건을 추가하거나 기존의 조건을 변경할 때 모든 switch문을 찾아서 코드를 고쳐야 할지도 모른다.

* switch expression : 일단 switch문과는 다른것이다. 표현식이고 그 결과를 담을 수 있는것이다. java 17버전 이상부터 사용가능
```c
int result = switch (type) {
    case "full-time" -> 120;
    case "part-time" -> 80;

    case"temporal" -> 32;
}
```

# 반복문
## 반복문 (Loops)

* 프로그래밍 언어 초기부터 있었던 반복문은 처음엔 별다른 대안이 없어서 간과했지만 최근 java와 같은 언어에서 함수형 프로그래밍을 지원하면서 반복문에 비해 더 나은 대안책이 생겼다.
* "반복문을 파이프라인으로 바꾸는 (Replace Loop with Pipeline)" 리팩토링을 적용하면 필터나 맵핑과 같은 파이프라인 기능을 사용해 보다 빠르게 어떤 작업을 하는지 파악할 수 있다.

## 반복문을 파이프라인으로 바꾸기 (Replace Loop with Pipeline)

* 콜렉션 파이프라인 (자바의 Stream, C#의 LINQ)
* 고전적인 반복문을 파이프라인 오퍼레이션을 사용해 표현하면 코드를 더 명확하게 만들 수 있다.
 - 필터 (filter) : 전달받은 조건의 true에 해당하는 데이터만 다음 오퍼레이션으로 전달.
 - 맵 (map) : 전달받은 함수를 사용해 입력값을 원하는 출력값으로 변환하여 다음 오퍼레이션으로 전달

```c
for ( Author a : authors ) {
   if ( a.company.equals(company) ) {
      var handle = a.twitterHandle;
      if ( handle != null ) 
         result.add(handle);
      }
   }
}
```
==> 이렇게 수정가능
```c
authors.stream()
     .filter(author -> author.company.equals(company))
     .map(author -> author.twitterHandle)
     .filter(t -> t != null)
     .collect(Collectors.toList());
```

# 성의없는 요소
## 성의 없는 요소 (Lazy Element)

* 여러 프로그래밍적인 요소(변수, 메소드, 클래스 등)를 만드는 이유
 - 나중에 발생할 변화를 대비해서..
 - 해당 함수 또는 클래스를 재사용하려고..
 - 의미있는 이름을 지어주려고..
* 가끔 그렇게 예상하고 만들어 놓은 요소들이 기대에 부응하지 못하는 경우가 있는데 그런 경우에 해당 요소들을 제거해야 한다.
* 관련 리팩토링 기술
 - "함수 인라인"
 - "클래스 인라인"
 - 불필요한 상속 구조는 "계층 합치기 (Collapse Hierarchy)"를 사용할 수 있다.

## 계층합치기 (Collapse Hierarchy)

* 상속 구조를 리팩토링하는 중에 기능을 올리고 내리다 보면 하위클래스와 상위클래스 코드에 차이가 없는 경우가 발생할 수 있다. 그런 경우에 그 둘을 합칠 수 있다.
* 하위 클래스와 상위클래스 중에 어떤 것을 없애야 하는가? ( 둘중에 보다 이름이 적절한 쪽을 선택하지만, 애매하다면 어느 쪽을 선택해도 문제없음)

# 추측성 일반화
## 추측성 일반화 (Speculative Generality)

* 나중에 이러 저러한 기능이 생길 것으로 예상하여, 여러 경우에 필요로 할만한 기능을 만들어 놨지만 "그런 일은 없었고..." 결국에 쓰이지 않는 코드가 발생한 경우
* XP의 YAGNI(You aren't gonna need it) 원칙을 따르자.
* 관련 리팩토링
 - 추상 클래스를 만들었지만 크게 유요하지 않다면 "계층 합치기(Collapse Hierarchy)"
 - 불필요한 위임은 "함수 인라인 (Inline Function)" 또는 "클래스 인라인"
 - 사용하지 않는 매개변수를 가진 함수는 "함수 선언 변경하기"
 - 오로지 테스트 코드에서만 사용하고 있는 코드는 "죽은 코드 제거하기 (Remove Dead Code)"

## 죽은 코드 제거하기 (Remove Dead Code)

* 사용하지 않는 코드가 애플리케이션 성능이나 기능에 영향을 끼치지는 않는다.
* 하지만 해당 소프트웨어가 어떻게 동작하는지 이해하려는 사람들에게는 꽤 고통을 줄 수 있다.
* 실제로 나중에 필요해진 코드라 하더라도 지금 쓰이지 않는 코드라면 (주석으로 감싸는게 아니라) 삭제해야 한다.
 - 나중에 정말로 다시 필요해진다면 git과 같은 버전 관리 시스템을 사용해 복원할 수 있다.

[intelliJ 와 eclipse에서의 죽은 코드 찾는 방법](https://yjh5369.tistory.com/entry/Eclipse-Tip-Code-Minings-IntelliJ-tip-code-vision)


# 임시 필드
## 임시 필드 (Temporary Field)

* 클래스에 있는 어떤 필드가 특정한 경우에만 값을 갖는 경우
* 어떤 객체의 필드가 "특정한 경우에만" 값을 가진다는 것을 이해하는 것은 일반적으로 예상하지 못하기 때문에 이해하기 어렵다
* 관련 리팩토링
 - "클래스 추출하기"를 사용해 해당 변수들을 옮길 수 있다.
 - "함수 옮기기"을 사용해서 해당 변수를 사용하는 함수를 특정 클래스로 옮길 수 있다.
 - "특이 케이스 추가하기"를 적용해 "특정한 경우에 의해 당하는 클래스를 만들어 해당 조건을 제거 할 수 있다.

## 특이 케이스 추가하기 (Introduce Special Case)

* 어떤 필드의 특정한 값에 따라 동일하게 동작하는 코드가 반복적으로 나타난다면, 해당 필드를 감싸는 "특별한 케이스"를 만들어 해당 조건을 표현할 수 있다.
* 이러한 매커니즘을 "특이 케이스 패턴"이라고 부르고 "Null Object 패턴"을 이러한 패턴의 특수한 형태라고 볼 수 있다.

# 메시지 체인
## 메시지 체인 (Message Chains)

* 레퍼런스를 따라 계속해서 메소드 호출이 이어지는 코드
 - 예) this.member.getCredit().getLevel().getDescription()
* 해당 코드의 클라이언트가 코드 체인을 모두 이해해야한다.
* 체인중 일부가 변경된다면 클라이언트의 코드도 변경해야 한다.
* 관련 리팩토링
 - "위임 숨기기 (Hide Delegate)"를 사용해 메시지 체인을 캡슐화를 할 수 있다.
 - "함수 추출하기 (Extract Function)"로 메시지 체인 일부를 함수로 추출한 "함수 옮기기 (Move Function)"으로 해당 함수를 적절한 이동할 수 있다.

## 위임 숨기기 (Hide Delegate)

* 캡슐화 (Encapsulation)란 어떤 모듈이 시스템의 다른 모듈의 최소한으로 알아야한다는 것이다. 그래야 어떤 모듈을 변경할 때, 최소한의 모듈만 그 변경에 영향을 받을것이고, 그래야 무언가를 변경하기 쉽다.
* 처음 객체 지향에서 캡슐화를 배울 때 필드를 메소드로 숨기는 것이라 배우지만, 메소드 호출도 숨길 수 있다.
 - persion.deapartment().manager();   --->    person.getManager();
 - 이전의 코드는 Department를 통해 Manager에 접근할 수 있다는 정보를 알아야 하지만, getManager()를 통해 위임을 숨긴다면 클라이언트는 person의 getManager()만 알아도 된다. 나중에  getManager() 내부 구현이 바뀌더라도 getManager()를 사용한 코드는 그대로 유지할 수 있다.


# 중재자
## 중재자 (Middle Man)

* 캡슐화를 통해 내부의 구체적인 정보를 최대한 감출 수 있다. (캡슐화를 한다고 다 좋은 건 아니다. 정도가 있어야)
* 그러나, 어떤 클래스의 메소드가 대부분 다른 클래스로 메소드 호출을 위임하고 있다면 중재자를 제거하고 클라이언트가 해당 클래스를 직접 사용하도록 코드를 개선할 수 있다.
* 관련 리팩토링
 * "중재자 제거하기 (Remove Middle Man)" 리팩토링을 사용해 클라이언트가 필요한 클래스를 직접 사용하도록 개선할 수 있다.
 * "함수 인라인 (Inline Function)"을 사용해서 메소드 호출한 쪽으로 코드를 보내서 중재자를 없앨 수도 있다.
 * "슈퍼클래스를 위임으로 바꾸기 (Replace Superclass with Delegate)"
 * "서브클래스를 위임으로 바꾸기 (Replace Subclass with Delegate)"

## 중재자 제거하기 (Remove Middle Man)

* "위임 숨기기"의 반대에 해당하는 리팩토링
* 필요한 캡슐화의 정도는 시간에 따라 그리고 상황에 따라 바뀔 수 있다.
* 캡슐화의 정도를 "중재자 제거하기"와 "위임 숨기기" 리팩토링을 통해 조절할 수 있다.
* 위임하고 있는 객체를 클라이언트가 사용할 수 있도록 getter를 제공하고, 클라이언트는 메시지 체인을 사용하도록 코드를 고친 뒤에 캡슐화에 사용했던 메소드를 제거한다.
* Law of Demeter 를 지나치게 따르기 보다는 상황에 맞게 활용하도록 하자.
 * 디미터의 법칙, "가장 가까운 객체만 사용한다."

## 슈퍼클래스를 위임으로 바꾸기 (Replace Superclass with Delegate)

* 객체지향에서 "상속"은 기존의 기능을 재사용하는 쉬우면서 강력한 방법이지만 때로는 적절하지 않은 경우도 있다.
* 서브클래스는 슈퍼클래스의 모든 기능을 지원해야 한다.
 * stack이라는 자료구조를 만들 때 List를 상속 받는 것이 좋을까?
* 서브클래스는 슈퍼클래스 자리를 대체하더라도 잘 동작해야 한다.
 * 리스코프 치환 원칙
* 그렇다면 상속을 사용하지 않는 것이 좋은가?
 * 상속은 적절한 경우에 사용한다면 매우 쉽고 효율적인 방법이다.
 * 따라서, 우선 상속을 적용한 이후에, 적절치 않다고 판단이 된다면 그때에 이 리팩토링을 적용하자!

## 서브클래스를 위임으로 바꾸기 (Replace Subclass with Delegate)

* 어떤 객체의 행동이 카테고리에 따라 바뀐다면, 보통 상속을 사용해서 일반적인 로직은 슈퍼클래스에 두고 특이한 케이스에 해당하는 로직을 서브클래스를 사용해 표현한다.
* 하지만, 대부분의 프로그래밍 언어에서 상속은 오직 한번만 사용할 수 있다.
  만약에 어떤 객체를 두가지 이상의 카테고리로 구분해야 한다면?
  위임을 사용하면 얼마든지 여러가지 이유로 여러 다른 객체로 위임을 할 수 있다.
* 슈퍼클래스가 바뀌면 모든 서브클래스에 영향을 줄 수 있다. 따라서 슈퍼클래스를 변경할 때 서브클래스까지 신경써야한다.
  만약에 서브클래스가 전혀 다른 모듈에 있다면?
  위임을 사용한다면 중간에 인터페이스를 만들어 의존성을 줄일 수 있다.
* "상속 대신 위임을 선호하라"는 결코 "상속은 나쁘다"라는 말이 아니다
  처음엔 상속을 적용하고 언제든지 이런 리팩토링을 사용해 위임으로 전환할 수 있다.


# 내부자 거래
## 내부자 거래 (Insider Trading)

* 어떤 모듈이 다른 모듈의 내부 정보를 지나치게 많이 알고 있는 코드 냄새, 그로인해 지나치게 강한 결합도(coupling)가 생길 수 있다.
* 적절한 모듈로 "함수 옮기기"와 "필드 옮기기"를 사용해서 결합도를 낮출 수 있다.
* 여러 모듈이 자주 사용하는 공통적인 기능은 새로운 모듈을 만들어 잘 관리하거나 "위임 숨기기"를 사용해 특정 모듈의 중재자처럼 사용할 수도 있다.
* 상속으로 인한 결합도를 줄일 때는 "슈퍼클래스 또는 서브클래스 위임으로 대체하기"를 사용할 수 있다.

# 거대한 클래스
## 거대한 클래스 (Large Class)

* 어떤 클래스가 너무 많은 일을 하다보면 필드도 많아지고 중복코드도 보이기 시작한다.
* 클라이언트가 해당 클래스가 제공하는 기능 중에 일부만 사용한다면 각각의 세부 기능을 별도의 클래스로 분리할 수 있다.
- "클래스 추출하기 (Extract Class)"를 사용해 관련있는 필드를 한 곳으로 모을 수 있다.
- 상속 구조를 만들 수 있다면 "슈퍼클래스 추출하기 (Extract Superclass)" 또는 "타입 코드를 서브클래스로 교체하기"를 적용할 수 있다.
* 클래스 내부에 산재하는 중복 코드는 메소드를 추출하여 제거할 수 있다.

## 슈퍼클래스 추출하기 (Extract Superclass)

* 두개의 클래스에서 비슷한 것들이 보인다면 상속을 적용하고, 슈퍼클래스로 "필드 올리기 (Pull Up Field)"와 "메소드 올리기 (Pull Up Method)"를 사용한다.
* 대안으로는 "클래스 추출하기"를 적용해 위임을 사용할 수 있다.
* 우선 간단히 상속을 적용한 이후, 나중에 필요하다면 "슈퍼클래스를 위임으로 교체하기"를 적용한다.


# 서로 다른 인터페이스의 대안 클래스들
## 서로 다른 인터페이스의 대안 클래스들 (Alternative Classess with Different Interfaces)

* 비슷한 일을 여러 곳에서 서로 다른 규약을 사용해 지원하고 있는 코드 냄새
* 대안 클래스로 사용하려면 동일한 인터페이스를 구현하고 있어야 한다.
* "함수 선언 변경하기"와 "함수 옮기기"를 사용해서 서로 동일한 인터페이스를 구현하게끔 코드를 수정할 수 있다.
* 두 클래스에서 일부 코드가 중복되는 경우에는 "슈퍼클래스 추출하기"를 사용해 중복된 코드를 슈퍼클래스로 옮기고 두 클래스를 새로운 슈퍼클래스의 서브클래스로 만들 수 있다.

# 데이터 클래스
## 데이터 클래스 (Data Class)

* 데이터 클래스 : public 필드 또는 필드에 대한 게터와 세터만 있는 클래스
- 코드가 적절한 위치에 있지 않기 때문에 이러한 냄새가 생길 수 있다.
- 예외적으로 "단계 쪼개기"에서 중간 데이터를 표현하는데 사용할 레코드는 불변 객체로 데이터를 전달하는 용도로 사용할 수 있다.
* public 필드를 가지고 있다면 "레코드 캡슐화하기 (Encapsulate Record)"를 사용해 게터나 세터를 통해서 접근하도록 고칠 수 있다.
* 변경되지 않아야 할 필드에는 "세터 제거하기"를 적용할 수 있다.
* 게터와 세터가 사용되는 메소드를 찾아보고 "함수 옮기기"를 사용해서 데이터 클래스로 옮길 수 있다.
* 메소드 전체가 아니라 일부 코드만 옮겨야 한다면 "함수 추출하기"를 선행한 뒤에 옮길 수 있다.

## 레코드 캡슐화하기 (Encapsulate Record)

* 변하는 데이터를 다룰 때는 레코드 보다는 객체를 선호한다.
- 레코드란 ? public 필드로 구성된 데이터 클래스를 말함
- 데이터를 메소드 뒤로 감추면 객체의 클라이언트는 어떤 데이터가 저장되어 있는지 신경쓸 필요가 없다.
- 필드 이름을 변경할 때 점진적으로 변경할 수 있다.
- 하지만 자바의 Record는 불변 객체라서 이런 리팩토링이 필요없다.
* public 필드를 사용하는 코드를 private 필드와 게터, 세터를 사용하도록 변경한다.

# 상속 포기
## 상속 포기 (Refused Bequest)

* 서브클래스가 슈퍼클래스에서 제공하는 메소드나 데이터를 잘 활용하지 않는다는 것은 해당 상속 구조에 문제가 있다는 뜻이다.
- 기존의 서브클래스 또는 새로운 서브클래스를 만들고 슈퍼클래스에서 "메소드와 필드를 내려주면 (Push Down Method / Field)" 슈퍼클래스에 공동으로 사용하는 기능만 남길 수 있다.
* 서브클래스가 슈퍼클래스의 기능을 재사용하고 싶지만 인터페이스를 따르고 싶지 않은 경우에는 "슈퍼클래스 또는 서브클래스를 위임으로 교체하기" 리팩토링을 적용할 수 있다.

# 주석
## 주석 (Comments)

* 주석을 남겨야 할 것 같다면 먼저 코드를 리팩토링 하라. 불필요한 주석을 줄일 수 있다.
- 모든 주석이 나쁘다는 것도 아니고, 주석을 쓰지 말자는 것도 아니다.
- 주석은 좋은 냄새에 해당하기도 한다.
* 관련 리팩토링
- "함수 추출하기"를 사용해 설명이 필요한 부분을 별도의 메소드로 빼낸다.
- "함수 선언부 변경하기"를 사용해 함수 이름을 재정의 할 수 있다.
- 시스템적으로 어떤 필요한 규칙이 있다면, "어서션 추가하기 (Introduce Assertion)"을 적용할 수 있다.

## 어서션 추가하기 (Introduce Assertion)

* 종종 코드로 표현하지 않았지만 기본적으로 가정하고 있는 조건들이 있다. 그런 조건을 알고리즘을 파악하거나 주석을 읽으면서 확인할 수 있다.
* 그러한 조건을 Assertion을 사용해서 보다 명시적으로 나타낼 수 있다.
* Assertion은 if나 switch 문과 달리 "항상" true이길 기대하는 조건을 표현할 때 사용한다.
- 프로그램이 Assertion에서 실패한다면 프로그래머의 실수로 생각할 수 있다.
- Assertion이 없어도 프로그램이 동작해야 한다. (자바에서는 컴파일 옵션으로 assert문을 사용하지 않도록 설정할 수도 있다.) -> '-ea (enable assertion)'을 빼면 된다.
* 특정 부분에선 특정한 상태를 가정하고 있다는 것을 명시적으로 나타냄으로써, 의사소통적인 가치를 지니고 있다.

